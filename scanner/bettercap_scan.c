#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <errno.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/stat.h>

#define MAX_IPS 4096
#define LINE_BUF 2048

static int sanitize_iface(const char *s) {
    if (!s || !*s) return 0;
    for (; *s; ++s) {
        if (!(isalnum((unsigned char)*s) || *s == '_' || *s == '-' || *s == '.')) return 0;
    }
    return 1;
}

static int add_unique_ip(char ips[][INET_ADDRSTRLEN], int *count, const char *ip) {
    for (int i = 0; i < *count; ++i) {
        if (strcmp(ips[i], ip) == 0) return 0;
    }
    if (*count >= MAX_IPS) return -1;
    strncpy(ips[*count], ip, INET_ADDRSTRLEN-1);
    ips[*count][INET_ADDRSTRLEN-1] = '\0';
    (*count)++;
    return 1;
}

/* write_temp_caplet: mkstemps to create name with .cap suffix */
static char *write_temp_caplet(const char *iface, int seconds) {
    const char *tmpdir = getenv("TMPDIR");
    if (!tmpdir) tmpdir = "/tmp";

    char template_path[256];
    if (snprintf(template_path, sizeof(template_path), "%s/bettercap_caplet_XXXXXX.cap", tmpdir) >= (int)sizeof(template_path)) {
        fprintf(stderr, "Путь к временному файлу слишком длинный\n");
        return NULL;
    }

    int fd = mkstemps(template_path, 4);
    if (fd == -1) {
        fprintf(stderr, "mkstemps(%s) failed: %s\n", template_path, strerror(errno));
        return NULL;
    }

    FILE *f = fdopen(fd, "w");
    if (!f) {
        fprintf(stderr, "fdopen failed for %s: %s\n", template_path, strerror(errno));
        close(fd);
        unlink(template_path);
        return NULL;
    }

    /* caplet: net.probe включается, ждём seconds, показываем таблицу, выключаем, и quit */
    fprintf(f,
        "# autogenerated caplet\n"
        "set events.stream false\n"
        "set http.server.enabled false\n"
        "net.probe on\n"
    );
    fprintf(f, "sleep %d\n", seconds);
    fprintf(f,
        "net.show\n"
        "net.probe off\n"
        "quit\n"
    );

    fflush(f);
    fclose(f);

    return strdup(template_path);
}

static int run_bettercap_and_collect(const char *iface, const char *caplet_path, char ips[][INET_ADDRSTRLEN], int *count) {
    if (access(caplet_path, R_OK) != 0) {
        fprintf(stderr, "caplet %s недоступен для чтения: %s\n", caplet_path, strerror(errno));
        return -1;
    }

    int p[2];
    if (pipe(p) == -1) {
        perror("pipe");
        return -1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        close(p[0]); close(p[1]);
        return -1;
    }

    if (pid == 0) {
        close(p[0]);
        if (dup2(p[1], STDOUT_FILENO) == -1) { perror("dup2"); _exit(127); }
        if (dup2(p[1], STDERR_FILENO) == -1) { /* ignore */ }
        close(p[1]);

        execlp("bettercap", "bettercap", "-iface", iface, "-caplet", caplet_path, (char *)NULL);
        perror("execlp(bettercap)");
        _exit(127);
    }

    close(p[1]);
    FILE *rf = fdopen(p[0], "r");
    if (!rf) {
        perror("fdopen");
        close(p[0]);
        return -1;
    }

    char line[LINE_BUF];
    while (fgets(line, sizeof(line), rf) != NULL) {
        fputs(line, stdout);

        char *saveptr = NULL;
        char *tok = strtok_r(line, " \t\r\n,;:[]()", &saveptr);
        while (tok) {
            struct in_addr a;
            if (inet_pton(AF_INET, tok, &a) == 1) {
                add_unique_ip(ips, count, tok);
            } else {
                char tmp[64];
                size_t L = strlen(tok);
                if (L > 0) {
                    size_t j = 0;
                    for (size_t i = 0; i < L && j+1 < sizeof(tmp); ++i) {
                        if (tok[i] == '/' || tok[i] == ':' || tok[i] == ',' || tok[i] == ';') break;
                        tmp[j++] = tok[i];
                    }
                    tmp[j] = '\0';
                    if (j > 0 && inet_pton(AF_INET, tmp, &a) == 1) {
                        add_unique_ip(ips, count, tmp);
                    }
                }
            }
            tok = strtok_r(NULL, " \t\r\n,;:[]()", &saveptr);
        }
    }

    fclose(rf);

    int status = 0;
    if (waitpid(pid, &status, 0) == -1) {
        perror("waitpid");
        return -1;
    }
    if (WIFEXITED(status)) {
        int code = WEXITSTATUS(status);
        if (code != 0) {
            fprintf(stderr, "bettercap завершился с кодом %d\n", code);
        }
    } else if (WIFSIGNALED(status)) {
        fprintf(stderr, "bettercap убит сигналом %d\n", WTERMSIG(status));
    }
    return 0;
}

static int write_hosts_file(const char *path, char ips[][INET_ADDRSTRLEN], int count) {
    FILE *f = fopen(path, "w");
    if (!f) {
        perror("fopen hosts");
        return -1;
    }
    for (int i = 0; i < count; ++i) {
        fprintf(f, "%s\n", ips[i]);
    }
    fclose(f);
    return 0;
}

static int run_nmap_from_hosts_with_os(const char *hosts_path) {
    pid_t pid = fork();
    if (pid == -1) { perror("fork"); return -1; }
    if (pid == 0) {
        execlp("nmap", "nmap", "-O", "-iL", hosts_path, (char *)NULL);
        perror("execlp(nmap)");
        _exit(127);
    }
    int status = 0;
    if (waitpid(pid, &status, 0) == -1) { perror("waitpid nmap"); return -1; }
    if (WIFEXITED(status)) {
        int code = WEXITSTATUS(status);
        if (code != 0) fprintf(stderr, "nmap завершился с кодом %d\n", code);
    } else if (WIFSIGNALED(status)) {
        fprintf(stderr, "nmap убит сигналом %d\n", WTERMSIG(status));
    }
    return 0;
}

static void print_usage(const char *pname) {
    printf("Usage: %s [iface] [-n] [-t seconds]\n", pname);
    printf("  iface       - интерфейс (default wlan1)\n");
    printf("  -n          - после bettercap запустить nmap с OS detection по найденным IP\n");
    printf("  -t seconds  - время сканирования bettercap в секундах (default 8)\n");
}

int main(int argc, char **argv) {
    const char *iface = "wlan1";
    int do_nmap = 0;
    int scan_seconds = 8;

    int ai = 1;
    if (ai < argc && argv[ai][0] != '-') {
        iface = argv[ai++];
    }
    for (; ai < argc; ++ai) {
        if (strcmp(argv[ai], "-n") == 0) do_nmap = 1;
        else if (strcmp(argv[ai], "-h") == 0 || strcmp(argv[ai], "--help") == 0) {
            print_usage(argv[0]);
            return 0;
        } else if (strcmp(argv[ai], "-t") == 0) {
            if (ai + 1 >= argc) { fprintf(stderr, "-t requires an argument\n"); return 1; }
            scan_seconds = atoi(argv[++ai]);
            if (scan_seconds <= 0) scan_seconds = 8;
        } else {
            fprintf(stderr, "Unknown arg: %s\n", argv[ai]);
            print_usage(argv[0]);
            return 1;
        }
    }

    if (!sanitize_iface(iface)) {
        fprintf(stderr, "Неверное имя интерфейса: %s\n", iface);
        return 1;
    }

    if (geteuid() != 0) {
        fprintf(stderr, "Внимание: рекомендуется запускать как root (bettercap и nmap -O требуют прав).\n");
    }

    char *caplet_path = write_temp_caplet(iface, scan_seconds);
    if (!caplet_path) {
        fprintf(stderr, "Не удалось создать временный caplet\n");
        return 1;
    }
    fprintf(stderr, "Создан временный caplet: %s\n", caplet_path);
    fprintf(stderr, "Запуск bettercap на %d сек...\n", scan_seconds);

    char ips[MAX_IPS][INET_ADDRSTRLEN];
    int ip_count = 0;
    memset(ips, 0, sizeof(ips));

    if (run_bettercap_and_collect(iface, caplet_path, ips, &ip_count) != 0) {
        fprintf(stderr, "Ошибка при запуске bettercap\n");
        unlink(caplet_path);
        free(caplet_path);
        return 1;
    }

    if (ip_count == 0) {
        fprintf(stderr, "Хосты не найдены в выводе bettercap.\n");
    } else {
        fprintf(stderr, "Найдено %d уникальных IP. Записываю hosts.txt\n", ip_count);
        if (write_hosts_file("hosts.txt", ips, ip_count) != 0) {
            unlink(caplet_path);
            free(caplet_path);
            return 1;
        }
        fprintf(stderr, "hosts.txt создан (один IP на строку)\n");
    }

    unlink(caplet_path);
    free(caplet_path);

    if (do_nmap && ip_count > 0) {
        fprintf(stderr, "Запуск nmap -O -iL hosts.txt для OS detection (рекомендуется root)...\n");
        if (run_nmap_from_hosts_with_os("hosts.txt") != 0) {
            fprintf(stderr, "Ошибка запуска nmap\n");
            return 1;
        }
    } else if (do_nmap) {
        fprintf(stderr, "Нет IP для сканирования — nmap не будет запущен.\n");
    } else {
        printf("Если хочешь OS detection: sudo %s %s -n -t %d\n", argv[0], iface, scan_seconds);
    }

    return 0;
}
